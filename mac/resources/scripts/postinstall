#!/bin/bash
#
# Gnosis VPN Post-Installation Script
#
# This script runs after the package payload is installed.
# It performs:
# - Configuration file generation (config.toml)
# - Backup of existing configuration (if present)
# - Final permission adjustments
# - Optional convenience symlinks
#
# Arguments:
#   $1: Full path to the installation package
#   $2: Full path to the installation destination (target volume)
#   $3: Mountpoint of the destination volume
#   $4: Root directory "/" for the current system
#
# Environment variables from Distribution.xml choices:
#   INSTALLER_CHOICE_NETWORK: "rotsee" or "dufour"
#   INSTALLER_CHOICE_LOGLEVEL: "debug" or "info"

set -euo pipefail

# Source unified logging library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/logging.sh"

# Setup logging
setup_logging "postinstall"

# Parameter validation and defaults
PACKAGE_PATH="${1:-}"
TARGET_VOLUME="${2:-/}"
MOUNTPOINT="${3:-/}"
ROOT_DIR="${4:-/}"

# Path joining function to avoid double slashes
join_path() {
    local base="$1"
    local path="$2"
    if [[ "$base" == "/" ]]; then
        echo "$path"
    else
        echo "${base}${path}"
    fi
}

# Ensure we have required parameters
if [[ -z $PACKAGE_PATH ]]; then
    log_error "Missing required parameter: package path"
    exit 1
fi

# Configuration
CONFIG_DIR="$(join_path "$TARGET_VOLUME" "/etc/gnosisvpn")"
CONFIG_FILE="${CONFIG_DIR}/config.toml"
VERSION_FILE="${CONFIG_DIR}/version.txt"
TEMPLATE_DIR_BUNDLE="${SCRIPT_DIR}/../config/templates"
TEMPLATE_DIR_INSTALLED="${CONFIG_DIR}/templates"
BIN_DIR="$(join_path "$TARGET_VOLUME" "/usr/local/bin")"
UI_STAGING_DIR="$(join_path "$TARGET_VOLUME" "/usr/local/share/gnosisvpn")"
UI_STAGED_ARCHIVE="${UI_STAGING_DIR}/gnosis_vpn-app.tar.gz"
UI_TARGET_APP="$(join_path "$TARGET_VOLUME" "/Applications/Gnosis VPN.app")"

INSTALLED_LOG_DIR_PATH="/Library/Logs/GnosisVPN"
INSTALLED_LIB_DIR_PATH="/Library/Application Support/GnosisVPN"

# Rollback mechanism
ROLLBACK_STEPS=()
ROLLBACK_ENABLED=true
PREV_CONFIG_FILE=""

# Get installer version from package (if available) or use current date
INSTALLER_VERSION="${INSTALLER_VERSION:-$(date +%Y%m%d-%H%M%S)}"

# Extract version from package filename if available
if [[ "$PACKAGE_PATH" =~ GnosisVPN-Installer-([^/]+)\.pkg ]]; then
    INSTALLER_VERSION="${BASH_REMATCH[1]}"
fi

load_installer_choices() {
    local choice_dir="/Library/Logs/GnosisVPN/installer"
    local network_choice_file="${choice_dir}/network_choice"
    local loglevel_choice_file="${choice_dir}/loglevel_choice"

    INSTALLER_CHOICE_NETWORK="rotsee"
    INSTALLER_CHOICE_LOGLEVEL="info"

    if [[ -f "$network_choice_file" ]]; then
        log_info "Loading network choice from $network_choice_file"
        # shellcheck disable=SC1090
        source "$network_choice_file"
    else
        log_warn "Network choice file not found, defaulting to rotsee"
    fi

    if [[ -f "$loglevel_choice_file" ]]; then
        log_info "Loading log level choice from $loglevel_choice_file"
        # shellcheck disable=SC1090
        source "$loglevel_choice_file"
    else
        log_warn "Log level choice file not found, defaulting to info"
    fi
}

# Rollback functions
rollback_restore_config() {
    if [[ -n "$PREV_CONFIG_FILE" ]] && [[ -f "$PREV_CONFIG_FILE" ]]; then
        log_info "Restoring previous configuration"
        mv -f "$PREV_CONFIG_FILE" "$CONFIG_FILE" || true
    fi
}

rollback_remove_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        log_info "Removing newly created configuration"
        rm -f "$CONFIG_FILE" || true
    fi
}

# Add a rollback step
add_rollback_step() {
    local step="$1"
    ROLLBACK_STEPS+=("$step")
    log_debug "Rollback: Registered step - $step"
}

# Execute rollback
execute_rollback() {
    if [[ "$ROLLBACK_ENABLED" != "true" ]]; then
        return 0
    fi

    log_section "ERROR: Installation failed, executing rollback"

    local steps="${#ROLLBACK_STEPS[@]}"
    if [[ $steps -eq 0 ]]; then
        log_warn "No rollback steps registered"
        return 0
    fi

    log_info "Rolling back $steps step(s)..."

    # Execute rollback steps in reverse order
    for ((i=${#ROLLBACK_STEPS[@]}-1; i>=0; i--)); do
        local step="${ROLLBACK_STEPS[$i]}"
        log_info "Rollback step $((steps - i))/$steps: $step"

        # Call the rollback function directly (no eval)
        if "$step"; then
            log_success "Rollback step completed"
        else
            log_warn "Rollback step failed (continuing anyway)"
        fi
    done

    log_section "Rollback completed"
}

# Set up trap for automatic rollback on error
trap 'execute_rollback' ERR EXIT

# Disable rollback after successful installation
disable_rollback() {
    ROLLBACK_ENABLED=false
    trap - ERR EXIT
}

# Check if previous installation exists
check_previous_installation() {
    log_info "Checking for previous installation..."

    local has_previous=false
    local previous_version=""

    # Check for version file
    if [[ -f "$VERSION_FILE" ]]; then
        previous_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")
        log_info "Found previous installation version: $previous_version"
        has_previous=true
    fi

    # Check for existing binaries
    if [[ -f "$BIN_DIR/gnosis_vpn-root" ]] || [[ -f "$BIN_DIR/gnosis_vpn-worker" ]] || [[ -f "$BIN_DIR/gnosis_vpn-ctl" ]]; then
        log_info "Found existing binaries in $BIN_DIR"
        has_previous=true

        if [[ -z "$previous_version" ]]; then
            previous_version="legacy"
            log_info "Legacy installation detected (no version file)"
        fi
    fi

    if [[ "$has_previous" == true ]]; then
        log_info "Previous installation detected (version: $previous_version)"
        echo "update"
    else
        log_info "No previous installation found"
        echo "fresh"
    fi
}

# Update binary if changed
update_binary() {
    local source_path="$1" # Source binary from package payload
    local target_path="$2"
    local owner="$3"
    local group="$4"
    local mode="$5"

    log_info "Updating $target_path..."
    # Copy new binary
    if cp "$source_path" "$target_path"; then
        chmod "$mode" "$target_path"
        chown "$owner:$group" "$target_path" 2>/dev/null || true
        log_success "Updated $target_path"
        return 0
    else
        log_error "Failed to update $target_path"
        return 1
    fi
}

# Save current installation version
save_version_info() {
    log_info "Saving installation version: $INSTALLER_VERSION"

    mkdir -p "$CONFIG_DIR"
    echo "$INSTALLER_VERSION" > "$VERSION_FILE"
    chmod 644 "$VERSION_FILE"
    chown root:wheel "$VERSION_FILE" 2>/dev/null || true

    log_success "Version saved to $VERSION_FILE"
}

# Create dedicated system user for Gnosis VPN service
create_system_user() {
    log_info "Creating dedicated system user for Gnosis VPN service..."

    local username="gnosisvpn"
    local fullname="Gnosis VPN Service"
    local homedir="$INSTALLED_LIB_DIR_PATH"
    local shell="/bin/bash"

    # Find next available system UID (typically 200-499 range for system users)
    local uid
    for uid in {200..499}; do
        if ! dscl . -read "/Users/$username" UniqueID >/dev/null 2>&1 && \
           [[ -z "$(dscl . -search /Users UniqueID "$uid")" ]]; then
            break
        fi
    done

    # Check if user already exists
    if dscl . -read "/Users/$username" >/dev/null 2>&1; then
        log_info "System user '$username' already exists"

        # Verify it's configured correctly
        local existing_uid
        existing_uid=$(dscl . -read "/Users/$username" UniqueID | awk '{print $2}')
        local existing_home
        existing_home=$(dscl . -read "/Users/$username" NFSHomeDirectory | cut -d' ' -f2-)

        log_info "Existing user details: UID=$existing_uid, Home=$existing_home"

        # Ensure home directory exists and has correct permissions
        if [[ ! -d "$existing_home" ]]; then
            log_info "Creating missing home directory: $existing_home"
            mkdir -p "$existing_home"
            chown "$username:gnosisvpn" "$existing_home"
            chmod 750 "$existing_home"
        fi

        return 0
    fi

    log_info "Creating system user: $username (UID: $uid)"

    # Create the user record
    dscl . -create "/Users/$username"
    dscl . -create "/Users/$username" UserShell "$shell"
    dscl . -create "/Users/$username" RealName "$fullname"
    dscl . -create "/Users/$username" UniqueID "$uid"
    dscl . -create "/Users/$username" PrimaryGroupID 20  # staff group initially
    dscl . -create "/Users/$username" NFSHomeDirectory "$homedir"

    # Hide user from login window and Users & Groups preferences
    dscl . -create "/Users/$username" IsHidden 1

    log_success "System user '$username' created successfully (UID: $uid)"
}

# Create dedicated group for Gnosis VPN operations
create_system_group() {
    log_info "Creating dedicated system group for Gnosis VPN..."

    local groupname="gnosisvpn"
    local current_user
    current_user=$(logname 2>/dev/null || who am i | awk '{print $1}' || echo "unknown")

    # Find next available system GID (typically 200-499 range for system groups)
    local gid
    for gid in {200..499}; do
        if ! dscl . -read "/Groups/$groupname" PrimaryGroupID >/dev/null 2>&1 && \
           [[ -z "$(dscl . -search /Groups PrimaryGroupID "$gid")" ]]; then
            log_info "Selected GID $gid for group '$groupname'"
            break
        fi
    done
    log_info "Using GID $gid for group '$groupname'"

    # Check if group already exists
    if dscl . -read "/Groups/$groupname" >/dev/null 2>&1; then
        log_info "System group '$groupname' already exists"

        # Check if current user is already in the group
        local group_members
        group_members=$(dscl . -read "/Groups/$groupname" GroupMembership 2>/dev/null | cut -d' ' -f2- || echo "")

        if [[ "$group_members" == *"$current_user"* ]]; then
            log_info "Current user '$current_user' is already in group '$groupname'"
        else
            log_info "Adding current user '$current_user' to existing group '$groupname'"
            dseditgroup -o edit -a "$current_user" -t user "$groupname"
            log_success "User '$current_user' added to group '$groupname'"
        fi

        return 0
    fi

    log_info "Creating system group: $groupname (GID: $gid)"

    # Create the group record
    dscl . -create "/Groups/$groupname"
    dscl . -create "/Groups/$groupname" PrimaryGroupID "$gid"
    dscl . -create "/Groups/$groupname" RealName "Gnosis VPN System Group"
    dscl . -create "/Groups/$groupname" RecordName "$groupname"

    # Add current user to the group
    if [[ "$current_user" != "unknown" ]] && [[ "$current_user" != "root" ]]; then
        log_info "Adding current user '$current_user' to group '$groupname'"
        dseditgroup -o edit -a "$current_user" -t user "$groupname"
        # ===
        # Critical Network Entitlements Needed:
        dseditgroup -o edit -a "$groupname" -t user _networkd
        # com.apple.developer.networking.networkextension - For VPN/tunnel creation
        # com.apple.security.network.server - For binding to sockets
        # com.apple.security.network.client - For outbound connections
        # com.apple.developer.system-extension.install - For system extensions
        # ===

        log_success "User '$current_user' added to group '$groupname'"
    else
        log_warn "Could not determine current user or user is root - skipping group membership"
    fi

    log_success "System group '$groupname' created successfully (GID: $gid)"
}

# Update system user's primary group to gnosisvpn
update_user_group() {
    log_info "Updating system user's primary group..."

    local username="gnosisvpn"
    local groupname="gnosisvpn"

    # Get group GID
    local gid
    if ! gid=$(dscl . -read "/Groups/$groupname" PrimaryGroupID 2>/dev/null | awk '{print $2}'); then
        log_error "Could not find GID for group '$groupname'"
        return 1
    fi

    # Update user's primary group
    dscl . -create "/Users/$username" PrimaryGroupID "$gid"

    # Update home directory ownership
    local homedir
    homedir=$(dscl . -read "/Users/$username" NFSHomeDirectory | cut -d' ' -f2-)
    if [[ -d "$homedir" ]]; then
        chown "$username:$groupname" "$homedir"
        log_info "Updated home directory ownership: $homedir"
    fi

    log_success "User '$username' primary group updated to '$groupname' (GID: $gid)"
}

# Configure plist with runtime values
configure_plist() {
    local source_plist="$1"
    local target_plist="$2"

    if [[ ! -f "$source_plist" ]]; then
        log_error "Source plist not found: $source_plist"
        return 1
    fi

    log_info "Configuring plist with runtime paths..."

    # Copy and configure the plist with actual paths
    cp "$source_plist" "$target_plist"


    # Ensure proper permissions
    chmod 644 "$target_plist"
    chown root:wheel "$target_plist" 2>/dev/null || true

    return 0
}

# Install launchd service
install_launchd_service() {
    local installation_type="$1"

    log_info "Installing launchd service..."

    # Configuration
    local launchd_dir="/Library/LaunchDaemons"
    local plist_name="com.gnosisvpn.gnosisvpnclient.plist"
    local plist_path="${launchd_dir}/${plist_name}"

    # During installation, the plist is in the installer scripts directory
    local source_plist="${SCRIPT_DIR}/config/system/${plist_name}"
    # Fallback to development location if not found (for testing)
    # if [[ ! -f "$plist_path" ]]; then
    #     plist_path="${SCRIPT_DIR}/../config/system/${plist_name}"
    # fi

    # Parameterize plist based on service mode
    if [[ "$INSTALLER_CHOICE_LOGLEVEL" == "debug" ]]; then
        log_info "Enabling debug logging"
        sed -i '' 's|<string>info</string>|<string>debug</string>|g' "$source_plist"
    else
        log_info "Enabling info logging"
        sed -i '' 's|<string>debug</string>|<string>info</string>|g' "$source_plist"
    fi
    sed -i '' "s|__NETWORK_NAME__|${INSTALLER_CHOICE_NETWORK}|g" "$source_plist"

    # Handle existing service (for updates/reinstalls)
    local service_was_running=false
    if [[ -f "$plist_path" ]]; then
        log_info "Existing service found, preparing for update..."

        # Check if service is currently running
        if launchctl print system/com.gnosisvpn.gnosisvpnclient >/dev/null 2>&1; then
            service_was_running=true
            log_info "Service is currently running, will restart after update"
        fi

        # Stop and unload existing service
        log_info "Stopping existing service..."
        launchctl bootout system "$plist_path" 2>/dev/null || true
        sleep 2

    fi

    # Install/update plist file
    if [[ -f "$source_plist" ]]; then
        log_info "Installing launchd plist: $plist_path"

        # Configure plist with runtime values
        if ! configure_plist "$source_plist" "$plist_path"; then
            log_error "Failed to configure plist file"
            return 1
        fi

        # Validate plist syntax
        if ! plutil -lint "$plist_path" >/dev/null 2>&1; then
            log_error "Invalid plist syntax detected after configuration"
            return 1
        fi

        log_success "Plist configured and validated successfully"

        # Load and start the service
        log_info "Loading Gnosis VPN service..."

        # Try to bootstrap the service
        local bootstrap_attempts=0
        local max_attempts=3
        local bootstrap_success=false

        while [[ $bootstrap_attempts -lt $max_attempts ]]; do
            if launchctl bootstrap system "$plist_path" 2>/dev/null; then
                bootstrap_success=true
                break
            else
                # Service might already be loaded, try to bootout first
                if [[ $bootstrap_attempts -eq 0 ]]; then
                    log_info "Service may already be loaded, attempting to reload..."
                    launchctl bootout system "$plist_path" 2>/dev/null || true
                    sleep 1
                fi
                ((bootstrap_attempts++))
                if [[ $bootstrap_attempts -lt $max_attempts ]]; then
                    sleep 2
                fi
            fi
        done

        if [[ "$bootstrap_success" == "true" ]]; then
            log_success "Gnosis VPN service loaded successfully"

            # Enable the service to start automatically
            log_info "Enabling service for automatic startup..."
            if launchctl enable system/com.gnosisvpn.gnosisvpnclient 2>/dev/null; then
                log_success "Service enabled for automatic startup"
            else
                log_warn "Failed to enable service (it may already be enabled)"
            fi

            # Wait a moment and verify it's running
            sleep 3
            if launchctl print system/com.gnosisvpn.gnosisvpnclient >/dev/null 2>&1; then
                log_success "Service is running successfully"

                # Check if the binary exists and is executable
                local binary_path="/usr/local/bin/gnosis_vpn-root"
                if [[ ! -f "$binary_path" ]]; then
                    log_warn "Binary not found: $binary_path - service may fail to start"
                    log_info "Ensure binaries are properly installed before the service starts"
                fi
            else
                log_warn "Service loaded but may not be running yet"
                log_info "This is normal if binaries haven't been downloaded yet"
                log_info "Check logs: tail -f $INSTALLED_LOG_DIR_PATH/gnosisvpn.log"
            fi
        else
            log_error "Failed to load Gnosis VPN service after $max_attempts attempts"
            exit 1
        fi
    else
        log_error "Launchd plist file not found: $source_plist"
        log_warn "Service will not start automatically at boot"

        # List possible locations for debugging
        log_info "Searched locations:"
        log_info "  - ${SCRIPT_DIR}/config/system/${plist_name}"
        log_info "  - ${SCRIPT_DIR}/../config/system/${plist_name}"
        return 1
    fi
}

# Verify plist deployment
verify_plist_deployment() {
    log_info "Verifying plist deployment..."

    local plist_path="/Library/LaunchDaemons/com.gnosisvpn.gnosisvpnclient.plist"
    local errors=0

    # Check if plist file exists
    if [[ ! -f "$plist_path" ]]; then
        log_error "Plist file not found at: $plist_path"
        ((errors++))
    else
        log_success "Plist file exists: $plist_path"

        # Check permissions
        local perms perms_normalized expected_plist_perms expected_plist_perms_normalized
        perms=$(stat -f "%Mp%Lp" "$plist_path")
        expected_plist_perms=644
        # Normalize both values so leading zeros do not affect comparison
        perms_normalized=$(printf "%o" $((8#$perms)))
        expected_plist_perms_normalized=$(printf "%o" $((8#$expected_plist_perms)))

        if [[ "$perms_normalized" != "$expected_plist_perms_normalized" ]]; then
            log_warn "Plist permissions are $perms_normalized, expected $expected_plist_perms_normalized"
        else
            log_success "Plist permissions correct: $expected_plist_perms_normalized"
        fi

        # Check ownership
        local owner
        owner=$(stat -f "%Su:%Sg" "$plist_path")
        if [[ "$owner" != "root:wheel" ]]; then
            log_warn "Plist ownership is $owner, expected root:wheel"
        else
            log_success "Plist ownership correct: root:wheel"
        fi

        # Validate syntax
        if plutil -lint "$plist_path" >/dev/null 2>&1; then
            log_success "Plist syntax is valid"
        else
            log_error "Plist syntax is invalid"
            ((errors++))
        fi
    fi

    # Check if service is loaded
    if launchctl print system/com.gnosisvpn.gnosisvpnclient >/dev/null 2>&1; then
        log_success "Service is loaded in launchd"
    else
        log_warn "Service is not loaded (this may be normal if binaries aren't ready)"
    fi

    return $errors
}

# Configure sudo privileges for gnosisvpn group
configure_sudo_privileges() {
    log_info "Configuring sudo privileges for gnosisvpn group..."

    local sudoers_file="/etc/sudoers.d/gnosis-vpn"
    local source_sudoers="${SCRIPT_DIR}/config/system/gnosis-vpn-sudoers"

    # Fallback to development location if not found (for testing)
    if [[ ! -f "$source_sudoers" ]]; then
        source_sudoers="${SCRIPT_DIR}/../config/system/gnosis-vpn-sudoers"
    fi

    if [[ ! -f "$source_sudoers" ]]; then
        log_error "Sudoers file not found: $source_sudoers"
        log_warn "Group members will need to use sudo for service management"
        return 1
    fi

    # Verify the gnosisvpn group exists
    if ! dscl . -read "/Groups/gnosisvpn" >/dev/null 2>&1; then
        log_warn "System group 'gnosisvpn' not found, skipping sudo configuration"
        return 0
    fi

    # Install sudoers file
    log_info "Installing sudoers configuration: $sudoers_file"
    cp "$source_sudoers" "$sudoers_file"

    # Set proper permissions for sudoers file
    chmod 440 "$sudoers_file"
    chown root:wheel "$sudoers_file"

    # Validate sudoers syntax
    if visudo -c -f "$sudoers_file" >/dev/null 2>&1; then
        log_success "Sudoers configuration installed and validated"
        log_info "Members of 'gnosisvpn' group can now manage the service without sudo password"
    else
        log_error "Invalid sudoers syntax detected, removing file"
        rm -f "$sudoers_file"
        return 1
    fi

    return 0
}

# Uninstall launchd service (for updates or uninstallation)
uninstall_launchd_service() {
    log_info "Stopping Gnosis VPN service..."

    local plist_path="/Library/LaunchDaemons/com.gnosisvpn.gnosisvpnclient.plist"

    if [[ -f "$plist_path" ]]; then
        # Stop and unload the service
        launchctl bootout system "$plist_path" 2>/dev/null || true
        log_success "Service stopped"
    else
        log_info "No existing service found"
    fi
}

# Check service status
check_service_status() {
    log_info "Checking service status..."

    if launchctl print system/com.gnosisvpn.gnosisvpnclient >/dev/null 2>&1; then
        local status_output
        status_output=$(launchctl print system/com.gnosisvpn.gnosisvpnclient)

        # Extract key information
        local state
        state=$(echo "$status_output" | grep "state =" | head -1 || echo "")
        local pid_info
        pid_info=$(echo "$status_output" | grep "pid =" | head -1 || echo "")
        local last_exit
        last_exit=$(echo "$status_output" | grep "last exit code =" | head -1 || echo "")
        local runs
        runs=$(echo "$status_output" | grep "runs =" | head -1 || echo "")

        log_info "Service status:"
        [[ -n "$state" ]] && log_info "  $state"
        [[ -n "$pid_info" ]] && log_info "  $pid_info"
        [[ -n "$last_exit" ]] && log_info "  $last_exit"
        [[ -n "$runs" ]] && log_info "  $runs"

        # Check if process is actually running
        if pgrep -f "gnosis_vpn-root" >/dev/null 2>&1; then
            local pid
            pid=$(pgrep -f "gnosis_vpn-root")
            log_success "VPN process is running (PID: $pid)"

            # Check if logs are being created
            if [[ -f "$INSTALLED_LOG_DIR_PATH/gnosisvpn.log" ]]; then
                local log_size
                log_size=$(wc -c < $INSTALLED_LOG_DIR_PATH/gnosisvpn.log 2>/dev/null || echo "0")
                if [[ "$log_size" -gt 0 ]]; then
                    log_success "Service is logging to $INSTALLED_LOG_DIR_PATH/gnosisvpn.log"
                else
                    log_info "Log file exists but is empty (service may be starting)"
                fi
            fi
        else
            log_warn "Service is loaded but process is not running"

            # Check for configuration issues
            if echo "$last_exit" | grep -q "78"; then
                log_warn "Last exit code 78 indicates configuration error"
                log_info "Check configuration file: /etc/gnosisvpn/config.toml"
                log_info "Verify HOPR RPC provider is accessible"
            fi
        fi
    else
        log_warn "Service is not loaded in launchd"
        log_info "Try loading manually: sudo launchctl bootstrap system /Library/LaunchDaemons/com.gnosisvpn.gnosisvpnclient.plist"
    fi
}

# Cleanup old backup files (keep only the 5 most recent)
cleanup_old_backups() {
    log_info "Cleaning up old backup files..."

    # Clean up old config backups
    if ls "$CONFIG_DIR"/*.backup 2>/dev/null | head -1 >/dev/null; then
        local config_backups
        config_backups=$(ls -t "$CONFIG_DIR"/*.backup 2>/dev/null | tail -n +6)
        if [[ -n "$config_backups" ]]; then
            echo "$config_backups" | xargs rm -f
            local removed_count
            removed_count=$(echo "$config_backups" | wc -l | tr -d ' ')
            log_info "Removed $removed_count old configuration backup(s)"
        fi
    fi

    # Clean up old binary backups
    if ls "$BIN_DIR"/*.backup-* 2>/dev/null | head -1 >/dev/null; then
        local binary_backups
        binary_backups=$(ls -t "$BIN_DIR"/*.backup-* 2>/dev/null | tail -n +11) # Keep 10 binary backups
        if [[ -n "$binary_backups" ]]; then
            echo "$binary_backups" | xargs rm -f
            local removed_count
            removed_count=$(echo "$binary_backups" | wc -l | tr -d ' ')
            log_info "Removed $removed_count old binary backup(s)"
        fi
    fi

    log_success "Backup cleanup completed"
}

# Backup existing configuration if present
backup_config() {
    local installation_type="$1"

    # Create config directory if it doesn't exist
    mkdir -p "$CONFIG_DIR"

    if [[ -f "$CONFIG_FILE" ]]; then
        local timestamp
        timestamp=$(date +%Y%m%d-%H%M%S)
        local backup_file="${CONFIG_DIR}/config-${timestamp}.toml.backup"

        if [[ "$installation_type" == "update" ]]; then
            log_info "Update detected: Creating configuration backup..."
        else
            log_info "Existing configuration found: Creating backup..."
        fi

        if cp "$CONFIG_FILE" "$backup_file"; then
            log_success "Backup created: $backup_file"
        else
            log_warn "Failed to create backup of existing config"
        fi
    fi
}

# Generate destinations configuration based on network selection
# Copy configuration files and create symlink
setup_configuration_files() {
    log_info "Setting up configuration files..."

    # Ensure config directory exists
    mkdir -p "$CONFIG_DIR"

    # Copy template files as configuration files (remove .template suffix)
    local template_files=("${TEMPLATE_DIR_INSTALLED}"/*.template)
    local copied=0

    for template_file in "${template_files[@]}"; do
        if [[ -f "$template_file" ]]; then
            local basename=$(basename "$template_file" .template)
            local target_file="${CONFIG_DIR}/${basename}"

            log_info "Installing configuration: $basename"
            cp "$template_file" "$target_file"
            chmod 644 "$target_file"
            copied=$((copied + 1))
        fi
    done

    if [[ $copied -eq 0 ]]; then
        log_error "No configuration templates found in $TEMPLATE_DIR_INSTALLED"
        return 1
    fi

    log_success "Installed $copied configuration file(s)"
}

# Create configuration symlink
create_config_symlink() {
    local installation_type="$1"

    log_info "Creating configuration symlink..."

    # Target configuration file
    local target_config="${CONFIG_DIR}/${INSTALLER_CHOICE_NETWORK}.toml"

    # Check if target configuration exists
    if [[ ! -f "$target_config" ]]; then
        log_warn "Configuration file not found: $target_config"
        log_info "Falling back to rotsee.toml"
        target_config="${CONFIG_DIR}/rotsee.toml"

        if [[ ! -f "$target_config" ]]; then
            log_error "Default configuration file not found: $target_config"
            return 1
        fi
    fi

    # Check if config.toml symlink already exists
    if [[ -L "$CONFIG_FILE" ]]; then
        local current_target
        current_target=$(readlink "$CONFIG_FILE" 2>/dev/null || echo "")
        local current_target_file="${CONFIG_DIR}/${current_target}"

        # Check if the symlink target actually exists
        if [[ -f "$current_target_file" ]]; then
            log_info "Configuration symlink already exists and is valid: config.toml -> $current_target"
            log_success "Preserving existing configuration symlink"
            return 0
        else
            log_warn "Existing symlink points to missing file: $current_target"
            log_info "Will recreate symlink to valid configuration"
        fi
    elif [[ -f "$CONFIG_FILE" ]]; then
        # It's a regular file, not a symlink - preserve it completely
        log_info "Configuration file exists as regular file (not symlink): config.toml"
        log_success "Preserving existing configuration file"
        return 0
    fi

    # Save previous config file for rollback if it exists
    if [[ -f "$CONFIG_FILE" ]] || [[ -L "$CONFIG_FILE" ]]; then
        PREV_CONFIG_FILE="${CONFIG_FILE}.pre-install"
        cp "$CONFIG_FILE" "$PREV_CONFIG_FILE" 2>/dev/null || true
        add_rollback_step "rollback_restore_config"
    else
        add_rollback_step "rollback_remove_config"
    fi

    # Remove existing config file/symlink (only if we determined it needs replacement)
    if [[ -f "$CONFIG_FILE" ]] || [[ -L "$CONFIG_FILE" ]]; then
        rm -f "$CONFIG_FILE"
    fi

    # Create symlink to the target configuration
    local relative_target
    relative_target=$(basename "$target_config")

    cd "$CONFIG_DIR"
    ln -s "$relative_target" "config.toml"
    cd - >/dev/null

    log_success "Configuration symlink created: config.toml -> $relative_target"
    log_info "Network: $INSTALLER_CHOICE_NETWORK"
}

copy_uninstall() {
    log_info "Copying uninstall script..."
    mkdir -p "$INSTALLED_LIB_DIR_PATH"
    cp "${SCRIPT_DIR}/uninstall.sh" "$INSTALLED_LIB_DIR_PATH/uninstall.sh"
    log_success "Uninstall script copied to $INSTALLED_LIB_DIR_PATH/uninstall.sh"
}

# Update binaries incrementally (only if changed)
update_binaries() {
    local installation_type="$1"

    log_info "Updating binaries..."
    binaries_array=(gnosis_vpn-root:root:wheel:750 gnosis_vpn-worker:root:gnosisvpn:750 gnosis_vpn-ctl:gnosisvpn:gnosisvpn:755 wg:root:wheel:755 wireguard-go:root:wheel:755 wg-quick:root:wheel:755)

    # For fresh installations, just copy all binaries
    if [[ "$installation_type" == "fresh" ]]; then
        log_info "Fresh installation: Installing all binaries..."

        for binary_info in "${binaries_array[@]}"; do
            IFS=":" read -r binary owner group mode <<< "$binary_info"
            if [[ -f "${2}/usr/local/bin/${binary}" ]]; then
                cp "${2}/usr/local/bin/${binary}" "$BIN_DIR/${binary}"
                chmod "$mode" "$BIN_DIR/${binary}"
                chown "$owner:$group" "$BIN_DIR/${binary}" 2>/dev/null || true
                log_success "Installed ${binary}"
            fi
        done
    else
        # For updates, check each binary individually
        log_info "Update installation: Checking which binaries need updates..."

        local updates_made=0

        for binary_info in "${binaries_array[@]}"; do
            IFS=":" read -r binary owner group mode <<< "$binary_info"
            if [[ -f "${2}/usr/local/bin/${binary}" ]]; then
                if update_binary "${2}/usr/local/bin/${binary}" "$BIN_DIR/${binary}" "$owner" "$group" "$mode"; then
                    updates_made=$((updates_made + 1))
                fi
            fi
        done

        if [[ $updates_made -gt 0 ]]; then
            log_success "Updated $updates_made binary(ies)"
        else
            log_info "All binaries are up to date"
        fi
    fi
    # Install management script
    setup_management_script
}

# Set proper file permissions
set_permissions() {
    log_info "Setting permissions..."

    local username="gnosisvpn"
    local groupname="gnosisvpn"

    # Set ownership and permissions for configuration directory
    mkdir -p "$CONFIG_DIR"
    chown -R root:$groupname "$CONFIG_DIR"
    chmod -R g+r "$CONFIG_DIR"
    chmod 644 "$CONFIG_FILE" 2>/dev/null || true
    log_info "Configuration directory permissions updated: $CONFIG_DIR"

    # Set ownership and permissions for log directory
    mkdir -p "$INSTALLED_LOG_DIR_PATH"
    chown -R $username:$groupname "$INSTALLED_LOG_DIR_PATH"
    chmod -R 755 "$INSTALLED_LOG_DIR_PATH"
    log_info "Log directory permissions updated: $INSTALLED_LOG_DIR_PATH"

    # add current user to the gnosisvpn group to allow interactions with binaries without privilige escalation
    CURRENT_USER=$(scutil <<< "show State:/Users/ConsoleUser" | awk '/Name :/ && !/loginwindow/ { print $3 }')
    log_info "Current user detected: $CURRENT_USER"
    dseditgroup -o edit -a "$CURRENT_USER" -t user gnosisvpn

    # Create and set permissions for runtime directory
    local runtime_dir="/var/run/gnosisvpn"
    mkdir -p "$runtime_dir"
    chown $username:$groupname "$runtime_dir"
    chmod 755 "$runtime_dir"
    log_info "Runtime directory created: $runtime_dir"

    # Create and set permissions for state directory
    local state_dir="$INSTALLED_LIB_DIR_PATH"
    chown -R $username:$groupname "$state_dir"
    chmod -R 700 "$state_dir"
    chmod 755 "$state_dir/uninstall.sh"
    log_info "State directory created: $state_dir"
    log_success "Permissions and ownership set"
}

# Verify binaries are in PATH
verify_path() {
    log_info "Verifying binaries are in PATH..."

    # Binaries are already in /usr/local/bin which is typically in PATH
    log_success "Binaries installed to $BIN_DIR (typically in PATH)"
    log_info "You should be able to run 'gnosis_vpn-root', 'gnosis_vpn-worker' and 'gnosis_vpn-ctl' from anywhere"
}

# Verify installation
verify_installation() {
    log_info "Verifying installation..."

    local errors=0

    for binary in gnosis_vpn-root gnosis_vpn-worker gnosis_vpn-ctl; do
        if [[ ! -x "$BIN_DIR/${binary}" ]]; then
            log_error "$BIN_DIR/${binary} binary not found or not executable"
            errors=$((errors + 1))
        fi
    done

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "Configuration file not found"
        errors=$((errors + 1))
    fi

    if [[ $errors -gt 0 ]]; then
        log_error "Installation verification failed with $errors error(s)"
        exit 1
    fi

    log_success "Installation verified successfully"
}

# Print installation summary
print_summary() {
    local installation_type="$1"

    if [[ "$installation_type" == "update" ]]; then
        log_section "Update Summary"
        log_info "Installation type: Update"
    else
        log_section "Installation Summary"
        log_info "Installation type: Fresh installation"
    fi

    log_info "Version: $INSTALLER_VERSION"
    log_info "Binary directory: $BIN_DIR"
    log_info "Configuration file: $CONFIG_FILE"
    log_info "Version file: $VERSION_FILE"
    log_info "Network: $INSTALLER_CHOICE_NETWORK"
    echo ""
    log_info "Installed binaries:"
    ls -lh "$BIN_DIR"/gnosis_vpn* 2>/dev/null || true
    echo ""

    # Show backup files if they exist
    if ls "$CONFIG_DIR"/*.backup 2>/dev/null | head -1 >/dev/null; then
        echo ""
        log_info "Configuration backups:"
        ls -lh "$CONFIG_DIR"/*.backup 2>/dev/null || true
    fi

    if ls "$BIN_DIR"/*.backup-* 2>/dev/null | head -1 >/dev/null; then
        echo ""
        log_info "Binary backups:"
        ls -lh "$BIN_DIR"/*.backup-* 2>/dev/null || true
    fi

    echo ""
    log_info "Service Management:"
    log_info "  The VPN service will start automatically at boot"
    log_info "  sudo launchctl kickstart system/com.gnosisvpn.gnosisvpnclient  # Restart service"
    log_info "  sudo launchctl bootout system/com.gnosisvpn.gnosisvpnclient    # Stop service"
    log_info "  gnosis_vpn-ctl status                           # Check VPN status"
    echo ""
    log_info "Management commands:"
    log_info "  gnosis_vpn-manager status   # Show installation status"
    log_info "  gnosis_vpn-manager backups  # List backup files"
    log_info "  gnosis_vpn-manager version  # Show installed version"
    echo ""
    log_info "Logs:"
    log_info "  tail -f $INSTALLED_LOG_DIR_PATH/gnosisvpn.log      # Service logs"
    echo ""
    log_info "Log file: $INSTALLER_LOG_FILE"

    if [[ "$installation_type" == "update" ]]; then
        log_success "Update completed successfully!"
    else
        log_success "Installation completed successfully!"
    fi
}

# Install UI application from staging to Applications
install_ui_application() {
    log_info "Installing UI application..."
    log_info "TARGET_VOLUME: $TARGET_VOLUME"
    log_info "UI_STAGING_DIR: $UI_STAGING_DIR"
    log_info "UI_STAGED_ARCHIVE: $UI_STAGED_ARCHIVE"
    log_info "UI_TARGET_APP: $UI_TARGET_APP"

    # Check if staging directory exists
    if [[ -d "$UI_STAGING_DIR" ]]; then
        log_info "Staging directory exists: $UI_STAGING_DIR"
        log_info "Contents of staging directory:"
        ls -la "$UI_STAGING_DIR" || log_warn "Failed to list staging directory contents"
    else
        log_warn "Staging directory does not exist: $UI_STAGING_DIR"
    fi

    # Add retry mechanism with delays for package extraction timing
    local retry_count=0
    local max_retries=5
    local retry_delay=2

    while [[ $retry_count -lt $max_retries ]]; do
        if [[ -f "$UI_STAGED_ARCHIVE" ]]; then
            log_info "Found staged UI archive at $UI_STAGED_ARCHIVE (attempt $((retry_count + 1)))"
            break
        else
            retry_count=$((retry_count + 1))
            if [[ $retry_count -lt $max_retries ]]; then
                log_info "UI archive not found, waiting ${retry_delay}s before retry (attempt $retry_count/$max_retries)"
                sleep $retry_delay
                # Check directory contents again
                if [[ -d "$UI_STAGING_DIR" ]]; then
                    log_info "Staging directory contents after wait:"
                    ls -la "$UI_STAGING_DIR" || true
                fi
            fi
        fi
    done

    if [[ ! -f "$UI_STAGED_ARCHIVE" ]]; then
        log_info "No staged UI archive found at $UI_STAGED_ARCHIVE after $max_retries attempts"
        log_info "UI application may be shipped separately; skipping copy"
        return 0
    fi

    # Remove existing app if present
    if [[ -d "$UI_TARGET_APP" ]]; then
        log_info "Removing existing UI application"
        rm -rf "$UI_TARGET_APP" || true
    fi

    # Ensure Applications directory exists
    local applications_dir
    applications_dir="$(join_path "$TARGET_VOLUME" "/Applications")"
    mkdir -p "$applications_dir"

    # Extract app archive into Applications
    if tar -xzf "$UI_STAGED_ARCHIVE" -C "$applications_dir"; then
        log_success "UI app extracted to Applications"

        # Set proper permissions
        chmod -R 755 "$UI_TARGET_APP" || true
        chown -R root:admin "$UI_TARGET_APP" 2>/dev/null || true
        xattr -dr com.apple.quarantine "$UI_TARGET_APP" 2>/dev/null || true

        # Clean up staged archive
        rm -f "$UI_STAGED_ARCHIVE" || true
        log_info "Removed staged archive"
    else
        log_warn "Failed to extract UI app archive to Applications"
    fi
}

# Validate service environment requirements
validate_service_environment() {
    log_info "Validating service environment..."

    local errors=0

    # Check required directories exist with proper ownership
    local required_dirs=(
        "/var/run/gnosisvpn:gnosisvpn:gnosisvpn:755"
        "$INSTALLED_LIB_DIR_PATH:gnosisvpn:gnosisvpn:750"
        "$INSTALLED_LOG_DIR_PATH:gnosisvpn:gnosisvpn:755"
    )

    for dir_spec in "${required_dirs[@]}"; do
        IFS=':' read -r dir_path expected_user expected_group expected_perms <<< "$dir_spec"

        if [[ ! -d "$dir_path" ]]; then
            log_error "Required directory missing: $dir_path"
            ((errors++))
        else
            # Check ownership
            local actual_owner
            actual_owner=$(/usr/bin/stat -f "%Su:%Sg" "$dir_path")
            if [[ "$actual_owner" != "$expected_user:$expected_group" ]]; then
                log_warn "Directory ownership incorrect: $dir_path (expected: $expected_user:$expected_group, actual: $actual_owner)"
            else
                log_success "✓ Directory ownership correct: $dir_path"
            fi

            # Check permissions
            local actual_perms actual_perms_normalized expected_perms_normalized
            actual_perms=$(/usr/bin/stat -f "%Mp%Lp" "$dir_path")
            # Normalize octal values so leading zeros do not affect comparisons
            actual_perms_normalized=$(printf "%o" $((8#$actual_perms)))
            expected_perms_normalized=$(printf "%o" $((8#$expected_perms)))

            if [[ "$actual_perms_normalized" != "$expected_perms_normalized" ]]; then
                log_warn "Directory permissions incorrect: $dir_path (expected: $expected_perms_normalized, actual: $actual_perms_normalized)"
            else
                log_success "✓ Directory permissions correct: $dir_path"
            fi
        fi
    done

    # Check that binary exists and is executable by gnosisvpn user
    local binary_path="/usr/local/bin/gnosis_vpn-worker"
    if [[ ! -f "$binary_path" ]]; then
        log_error "Binary not found: $binary_path"
        ((errors++))
    else
        if sudo -u gnosisvpn test -x "$binary_path"; then
            log_success "✓ Binary is executable by gnosisvpn user"
        else
            log_error "Binary is not executable by gnosisvpn user: $binary_path"
            ((errors++))
        fi
    fi

    # Check that config file exists and is readable by gnosisvpn user
    local config_path="/etc/gnosisvpn/config.toml"
    if [[ ! -f "$config_path" ]]; then
        log_error "Config file not found: $config_path"
        ((errors++))
    else
        if sudo -u gnosisvpn test -r "$config_path"; then
            log_success "✓ Config file is readable by gnosisvpn user"
        else
            log_error "Config file is not readable by gnosisvpn user: $config_path"
            ((errors++))
        fi
    fi

    if [[ $errors -eq 0 ]]; then
        log_success "Service environment validation passed"
    else
        log_warn "Service environment validation found $errors issue(s)"
        log_info "The service may not start properly until these issues are resolved"
    fi
}

setup_management_script() {
    if [[ -f "${SCRIPT_DIR}/manage-installation.sh" ]]; then
        cp "${SCRIPT_DIR}/manage-installation.sh" "$BIN_DIR/gnosis_vpn-manager"
        chmod 755 "$BIN_DIR/gnosis_vpn-manager"
        chown root:gnosisvpn "$BIN_DIR/gnosis_vpn-manager" 2>/dev/null || true
        log_info "Management script installed with gnosisvpn group"
        log_success "Installed management script: gnosis_vpn-manager"
    fi
}

# Copy log rotation configuration for newsyslog
copy_logs_rotation_conf() {
    local src_conf="${SCRIPT_DIR}/config/system/gnosisvpn.logrotate.conf"
    local dest_conf="/etc/newsyslog.d/gnosisvpn.conf"
    if [[ -f "$src_conf" ]]; then
        cp "$src_conf" "$dest_conf"
        chmod 644 "$dest_conf"
        chown root:wheel "$dest_conf" 2>/dev/null || true
        log_success "Installed log rotation config: $dest_conf"
    else
        log_warn "Log rotation config not found: $src_conf"
        ls -alR "${SCRIPT_DIR}/config/system/" || true
        ls -alR "${SCRIPT_DIR}/../config/system/" || true
    fi
}

# Main execution
main() {

    # Inject installer choices from temporary files (if they exist)
    load_installer_choices

    log_info "Install package: $PACKAGE_PATH"
    log_info "Target volume: $TARGET_VOLUME"
    log_info "Binary directory: $BIN_DIR"
    log_info "Configuration directory: $CONFIG_DIR"
    log_info "Configuration file: $CONFIG_FILE"
    log_info "Network: $INSTALLER_CHOICE_NETWORK"
    log_info "Log level: $INSTALLER_CHOICE_LOGLEVEL"

    # Determine installation type (fresh vs update)
    local installation_type
    installation_type=$(check_previous_installation)

    log_section "Installation Type: $installation_type"

    backup_config "$installation_type"
    copy_uninstall

    # Create system user and group
    create_system_group
    create_system_user
    update_user_group

    # Update binaries (incrementally for updates, full for fresh installs)
    update_binaries "$installation_type" "$TARGET_VOLUME"

    # Setup configuration files and create symlink
    setup_configuration_files
    create_config_symlink "$installation_type"

    # Set proper permissions
    set_permissions

    # Save version information
    save_version_info

    # Configure sudo privileges for service management
    configure_sudo_privileges

    # Install log rotation config
    copy_logs_rotation_conf

    # Validate service environment
    validate_service_environment

    # Install launchd service
    install_launchd_service "$installation_type"

    # Verify plist deployment
    verify_plist_deployment

    # Install UI application
    install_ui_application

    # Clean up old backup files
    cleanup_old_backups

    # Verify installation
    verify_path
    verify_installation

    # Check service status
    check_service_status

    # Print summary
    print_summary "$installation_type"

    # Disable rollback after successful completion
    disable_rollback

    # Log script completion
    log_script_end "success"
}

# Execute main function
main

exit 0
